<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Snake ‚Äî Minimal Retro</title>
<style>
  :root{
    --bg:#0b0e14; --fg:#e6e1cf; --accent:#98e024; --danger:#ff6c60; --muted:#3b4252;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:radial-gradient(1600px 1000px at 50% -10%,#101521,var(--bg));color:var(--fg);font:500 15px/1.35 system-ui,Segoe UI,Roboto,Helvetica,Arial;display:flex;align-items:center;justify-content:center;padding:18px}
  .wrap{width:min(96vw,860px)}
  .hud{display:flex;align-items:center;justify-content:space-between;gap:12px;background:#0f1421;border:1px solid #1f2433;border-radius:12px 12px 0 0;padding:12px 14px}
  .hud .group{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .hud .chip{background:#121a2b;border:1px solid #242b3b;border-radius:999px;padding:6px 10px;font-variant-numeric:tabular-nums}
  .hud label{display:flex;align-items:center;gap:6px}
  .hud input[type="range"]{accent-color:var(--accent)}
  canvas{display:block;width:100%;max-width:860px;aspect-ratio: 30/20;background:#0a0f1b;border:1px solid #1f2433;border-top:none;border-radius:0 0 12px 12px;box-shadow:0 18px 60px rgba(0,0,0,.35)}
  .keys{margin-top:10px;opacity:.85;text-align:center}
</style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div class="group">
        <strong>üêç Snake ‚Äî Retro</strong>
        <span class="chip">Score: <span id="score">0</span></span>
        <span class="chip">Best: <span id="best">0</span></span>
        <span class="chip">Length: <span id="len">3</span></span>
      </div>
      <div class="group">
        <label><input type="checkbox" id="wrap"> Wrap</label>
        <label>Speed <input type="range" id="speed" min="1" max="10" value="6"></label>
        <button id="pause">Pause</button>
        <button id="reset">Reset</button>
      </div>
    </div>
    <canvas id="c" width="900" height="600" aria-label="Snake game"></canvas>
    <div class="keys">Arrows/WASD to move ‚Ä¢ Space to pause ‚Ä¢ R to reset</div>
  </div>

<script>
(() => {
  const cvs = document.getElementById('c');
  const ctx = cvs.getContext('2d');
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const lenEl   = document.getElementById('len');
  const wrapEl  = document.getElementById('wrap');
  const speedEl = document.getElementById('speed');
  const pauseBtn= document.getElementById('pause');
  const resetBtn= document.getElementById('reset');

  // Grid
  const COLS = 30, ROWS = 20; // aspect ratio 30:20
  const CS = Math.floor(Math.min(cvs.width/COLS, cvs.height/ROWS));
  const ox = Math.floor((cvs.width - COLS*CS)/2);
  const oy = Math.floor((cvs.height - ROWS*CS)/2);

  // Save best in localStorage
  const BEST_KEY = 'snake-retro-best';
  let best = Number(localStorage.getItem(BEST_KEY) || 0);
  bestEl.textContent = best;

  // Game state
  let dir = {x:1,y:0}, nextDir = {x:1,y:0};
  let snake = [];
  let food = null;
  let score = 0;
  let paused = false;
  let dead = false;
  let timer = null; // setInterval handle

  function init(){
    dir = {x:1,y:0}; nextDir = {x:1,y:0};
    snake = [{x:5,y:10},{x:4,y:10},{x:3,y:10}];
    score = 0; paused = false; dead = false;
    scoreEl.textContent = score; lenEl.textContent = snake.length;
    spawnFood();
    setSpeedFromUI();
    draw();
  }

  function setSpeedFromUI(){
    const v = Number(speedEl.value); // 1..10
    const ms = 230 - v*18; // slower->faster
    if (timer) clearInterval(timer);
    timer = setInterval(tick, ms);
    pauseBtn.textContent = paused ? 'Resume' : 'Pause';
  }

  function spawnFood(){
    const taken = new Set(snake.map(p => p.x+','+p.y));
    let x,y; do { x = (Math.random()*COLS)|0; y = (Math.random()*ROWS)|0; } while(taken.has(x+','+y));
    food = {x,y};
  }

  function tick(){
    if (paused || dead) return;
    dir = nextDir;
    let nx = snake[0].x + dir.x;
    let ny = snake[0].y + dir.y;

    if (wrapEl.checked){
      nx = (nx + COLS) % COLS; ny = (ny + ROWS) % ROWS;
    } else {
      if (nx<0||ny<0||nx>=COLS||ny>=ROWS){ gameOver(); return; }
    }
    // self collision
    if (snake.some(s=>s.x===nx && s.y===ny)){ gameOver(); return; }

    snake.unshift({x:nx,y:ny});
    if (nx===food.x && ny===food.y){
      score += 10; scoreEl.textContent = score; lenEl.textContent = snake.length; spawnFood();
      if (score>best){ best=score; bestEl.textContent=best; localStorage.setItem(BEST_KEY,best); }
    } else {
      snake.pop();
    }
    draw();
  }

  function gameOver(){ dead = true; paused = true; pauseBtn.textContent='Restart'; }

  function draw(){
    // clear
    ctx.fillStyle = '#08101e'; ctx.fillRect(0,0,cvs.width,cvs.height);
    // grid backdrop
    ctx.strokeStyle = 'rgba(200,220,255,0.06)'; ctx.lineWidth = 1;
    for(let i=0;i<=COLS;i++){ const x=ox+i*CS+0.5; ctx.beginPath(); ctx.moveTo(x,oy); ctx.lineTo(x,oy+ROWS*CS); ctx.stroke(); }
    for(let j=0;j<=ROWS;j++){ const y=oy+j*CS+0.5; ctx.beginPath(); ctx.moveTo(ox,y); ctx.lineTo(ox+COLS*CS,y); ctx.stroke(); }

    // food
    if (food){
      const x = ox+food.x*CS, y=oy+food.y*CS;
      const g = ctx.createRadialGradient(x+CS*0.5,y+CS*0.5,1,x+CS*0.5,y+CS*0.5,CS*0.6);
      g.addColorStop(0,'#ffd4d1'); g.addColorStop(1,'#ff7a70');
      ctx.fillStyle = g; roundRect(x+3,y+3,CS-6,CS-6,6,true);
    }

    // snake
    for (let i=0;i<snake.length;i++){
      const s = snake[i]; const x = ox+s.x*CS, y = oy+s.y*CS;
      const light = 42 + Math.min(45, i*1.2);
      ctx.fillStyle = `hsl(115 65% ${light}%)`;
      roundRect(x+1.5,y+1.5,CS-3,CS-3,8,true);
    }

    // head outline
    const h = snake[0];
    ctx.strokeStyle = '#98e024'; ctx.lineWidth = 2;
    ctx.strokeRect(ox+h.x*CS+1, oy+h.y*CS+1, CS-2, CS-2);
  }

  function roundRect(x,y,w,h,r,fill){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    if(fill) ctx.fill(); else ctx.stroke();
  }

  // Input
  document.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    if (["arrowup","w"].includes(k) && dir.y!==1) nextDir={x:0,y:-1};
    else if (["arrowdown","s"].includes(k) && dir.y!==-1) nextDir={x:0,y:1};
    else if (["arrowleft","a"].includes(k) && dir.x!==1) nextDir={x:-1,y:0};
    else if (["arrowright","d"].includes(k) && dir.x!==-1) nextDir={x:1,y:0};
    else if (k===' ') { togglePause(); }
    else if (k==='r') { init(); }
  }, {passive:true});

  function togglePause(){
    if (dead){ init(); return; }
    paused = !paused; pauseBtn.textContent = paused ? 'Resume' : 'Pause';
  }

  speedEl.addEventListener('input', setSpeedFromUI);
  wrapEl.addEventListener('change', draw);
  pauseBtn.addEventListener('click', togglePause);
  resetBtn.addEventListener('click', init);

  // Fit canvas on resize (keep aspect ratio and crispness)
  function fit(){
    const maxW = Math.min(860, document.querySelector('.wrap').clientWidth);
    const ratio = COLS/ROWS;
    const cssW = maxW;
    const cssH = Math.floor(cssW/ratio);
    const dpr = Math.min(2, window.devicePixelRatio||1);
    cvs.style.width = cssW+'px';
    cvs.style.height = cssH+'px';
    cvs.width = Math.floor(cssW*dpr);
    cvs.height= Math.floor(cssH*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', () => { fit(); draw(); });

  fit();
  init();
})();
</script>
</body>
</html>